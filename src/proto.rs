// This file is @generated by prost-build.
/// Supported filter types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppliedFilter {
    #[prost(enumeration = "LensOverlayFilterType", tag = "1")]
    pub filter_type: i32,
    #[prost(oneof = "applied_filter::FilterPayload", tags = "3")]
    pub filter_payload: ::core::option::Option<applied_filter::FilterPayload>,
}
/// Nested message and enum types in `AppliedFilter`.
pub mod applied_filter {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Translate {
        #[prost(string, tag = "1")]
        pub target_language: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub source_language: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FilterPayload {
        #[prost(message, tag = "3")]
        Translate(Translate),
    }
}
/// Supported filter types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppliedFilters {
    #[prost(message, repeated, tag = "1")]
    pub filter: ::prost::alloc::vec::Vec<AppliedFilter>,
}
/// Supported filter types.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LensOverlayFilterType {
    UnknownFilterType = 0,
    Translate = 2,
    AutoFilter = 7,
}
impl LensOverlayFilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownFilterType => "UNKNOWN_FILTER_TYPE",
            Self::Translate => "TRANSLATE",
            Self::AutoFilter => "AUTO_FILTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_FILTER_TYPE" => Some(Self::UnknownFilterType),
            "TRANSLATE" => Some(Self::Translate),
            "AUTO_FILTER" => Some(Self::AutoFilter),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Platform {
    Unspecified = 0,
    Web = 3,
    LensOverlay = 6,
}
impl Platform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PLATFORM_UNSPECIFIED",
            Self::Web => "PLATFORM_WEB",
            Self::LensOverlay => "PLATFORM_LENS_OVERLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLATFORM_UNSPECIFIED" => Some(Self::Unspecified),
            "PLATFORM_WEB" => Some(Self::Web),
            "PLATFORM_LENS_OVERLAY" => Some(Self::LensOverlay),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Surface {
    Unspecified = 0,
    Chromium = 4,
    LensOverlay = 42,
}
impl Surface {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SURFACE_UNSPECIFIED",
            Self::Chromium => "SURFACE_CHROMIUM",
            Self::LensOverlay => "SURFACE_LENS_OVERLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SURFACE_UNSPECIFIED" => Some(Self::Unspecified),
            "SURFACE_CHROMIUM" => Some(Self::Chromium),
            "SURFACE_LENS_OVERLAY" => Some(Self::LensOverlay),
            _ => None,
        }
    }
}
/// Context information of the client sending the request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayClientContext {
    /// Required. Client platform.
    #[prost(enumeration = "Platform", tag = "1")]
    pub platform: i32,
    /// Optional. Client surface.
    #[prost(enumeration = "Surface", tag = "2")]
    pub surface: i32,
    /// Required. Locale specific context.
    #[prost(message, optional, tag = "4")]
    pub locale_context: ::core::option::Option<LocaleContext>,
    /// Required. Name of the package which sends the request to Lens Frontend.
    #[prost(string, tag = "6")]
    pub app_id: ::prost::alloc::string::String,
    /// Filters that are enabled on the client side.
    #[prost(message, optional, tag = "17")]
    pub client_filters: ::core::option::Option<AppliedFilters>,
    /// The rendering context info.
    #[prost(message, optional, tag = "20")]
    pub rendering_context: ::core::option::Option<RenderingContext>,
    /// Logging data.
    #[prost(message, optional, tag = "23")]
    pub client_logging_data: ::core::option::Option<ClientLoggingData>,
}
/// Describes locale context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocaleContext {
    /// The BCP 47 language tag used to identify the language of the client.
    #[prost(string, tag = "1")]
    pub language: ::prost::alloc::string::String,
    /// The CLDR region tag used to identify the region of the client.
    #[prost(string, tag = "2")]
    pub region: ::prost::alloc::string::String,
    /// The CLDR time zone ID used to identify the timezone of the client.
    #[prost(string, tag = "3")]
    pub time_zone: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RenderingContext {
    /// The rendering environment.
    #[prost(enumeration = "LensRenderingEnvironment", tag = "2")]
    pub rendering_environment: i32,
}
/// Contains data that can be used for logging purposes.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientLoggingData {
    /// Whether history is enabled.
    #[prost(bool, tag = "1")]
    pub is_history_eligible: bool,
}
/// The possible rendering environments.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LensRenderingEnvironment {
    RenderingEnvUnspecified = 0,
    RenderingEnvLensOverlay = 14,
}
impl LensRenderingEnvironment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RenderingEnvUnspecified => "RENDERING_ENV_UNSPECIFIED",
            Self::RenderingEnvLensOverlay => "RENDERING_ENV_LENS_OVERLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RENDERING_ENV_UNSPECIFIED" => Some(Self::RenderingEnvUnspecified),
            "RENDERING_ENV_LENS_OVERLAY" => Some(Self::RenderingEnvLensOverlay),
            _ => None,
        }
    }
}
/// Phase latency metadata for the Lens Overlay.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayPhaseLatenciesMetadata {
    #[prost(message, repeated, tag = "1")]
    pub phase: ::prost::alloc::vec::Vec<lens_overlay_phase_latencies_metadata::Phase>,
}
/// Nested message and enum types in `LensOverlayPhaseLatenciesMetadata`.
pub mod lens_overlay_phase_latencies_metadata {
    /// Represents a single point in time during the image preprocessing flow.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Phase {
        /// Data specific for each PhaseType. These should only be populated for
        /// "_END" PhaseTypes.
        #[prost(oneof = "phase::PhaseData", tags = "3, 4")]
        pub phase_data: ::core::option::Option<phase::PhaseData>,
    }
    /// Nested message and enum types in `Phase`.
    pub mod phase {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ImageDownscaleData {
            /// The size of the original image, in pixels.
            #[prost(int64, tag = "1")]
            pub original_image_size: i64,
            /// The size of the downscaled image, in pixels.
            #[prost(int64, tag = "2")]
            pub downscaled_image_size: i64,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ImageEncodeData {
            /// The type of the original Image. This only applies to IMAGE_ENCODE_END
            /// PhaseTypes
            #[prost(enumeration = "super::ImageType", tag = "1")]
            pub original_image_type: i32,
            /// The bytes size of the encoded image.
            #[prost(int64, tag = "2")]
            pub encoded_image_size_bytes: i64,
        }
        /// Data specific for each PhaseType. These should only be populated for
        /// "_END" PhaseTypes.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum PhaseData {
            /// Data specifically only relevant for IMAGE_DOWNSCALE_END PhaseType.
            #[prost(message, tag = "3")]
            ImageDownscaleData(ImageDownscaleData),
            /// Data specifically only relevant for IMAGE_ENCODE_END PhaseType.
            #[prost(message, tag = "4")]
            ImageEncodeData(ImageEncodeData),
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageType {
        Unknown = 0,
        Jpeg = 1,
        Png = 2,
        Webp = 3,
    }
    impl ImageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Jpeg => "JPEG",
                Self::Png => "PNG",
                Self::Webp => "WEBP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "JPEG" => Some(Self::Jpeg),
                "PNG" => Some(Self::Png),
                "WEBP" => Some(Self::Webp),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayClientLogs {
    /// The phase latency metadata for any image preprocessing required for the
    /// request.
    #[prost(message, optional, tag = "1")]
    pub phase_latencies_metadata: ::core::option::Option<
        LensOverlayPhaseLatenciesMetadata,
    >,
    /// The Lens Overlay entry point used to access lens.
    #[prost(
        enumeration = "lens_overlay_client_logs::LensOverlayEntryPoint",
        optional,
        tag = "2"
    )]
    pub lens_overlay_entry_point: ::core::option::Option<i32>,
    /// A unique identifier for associating events logged by lens asynchronously.
    #[prost(uint64, optional, tag = "3")]
    pub paella_id: ::core::option::Option<u64>,
    /// Whether the user has disabled metrics collection.
    #[prost(bool, optional, tag = "5")]
    pub metrics_collection_disabled: ::core::option::Option<bool>,
}
/// Nested message and enum types in `LensOverlayClientLogs`.
pub mod lens_overlay_client_logs {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LensOverlayEntryPoint {
        UnknownEntryPoint = 0,
        AppMenu = 1,
        PageContextMenu = 2,
        ImageContextMenu = 3,
        OmniboxButton = 4,
        ToolbarButton = 5,
        FindInPage = 6,
    }
    impl LensOverlayEntryPoint {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownEntryPoint => "UNKNOWN_ENTRY_POINT",
                Self::AppMenu => "APP_MENU",
                Self::PageContextMenu => "PAGE_CONTEXT_MENU",
                Self::ImageContextMenu => "IMAGE_CONTEXT_MENU",
                Self::OmniboxButton => "OMNIBOX_BUTTON",
                Self::ToolbarButton => "TOOLBAR_BUTTON",
                Self::FindInPage => "FIND_IN_PAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_ENTRY_POINT" => Some(Self::UnknownEntryPoint),
                "APP_MENU" => Some(Self::AppMenu),
                "PAGE_CONTEXT_MENU" => Some(Self::PageContextMenu),
                "IMAGE_CONTEXT_MENU" => Some(Self::ImageContextMenu),
                "OMNIBOX_BUTTON" => Some(Self::OmniboxButton),
                "TOOLBAR_BUTTON" => Some(Self::ToolbarButton),
                "FIND_IN_PAGE" => Some(Self::FindInPage),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClientPlatform {
    Unspecified = 0,
    LensOverlay = 2,
}
impl ClientPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLIENT_PLATFORM_UNSPECIFIED",
            Self::LensOverlay => "CLIENT_PLATFORM_LENS_OVERLAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLIENT_PLATFORM_UNSPECIFIED" => Some(Self::Unspecified),
            "CLIENT_PLATFORM_LENS_OVERLAY" => Some(Self::LensOverlay),
            _ => None,
        }
    }
}
/// Information about where to route the request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayRoutingInfo {
    /// Address to route the request to.
    #[prost(string, tag = "1")]
    pub server_address: ::prost::alloc::string::String,
    /// Cell to route the request to.
    #[prost(string, tag = "3")]
    pub cell_address: ::prost::alloc::string::String,
    /// Blade target to route the request to.
    #[prost(string, tag = "2")]
    pub blade_target: ::prost::alloc::string::String,
}
/// The cluster info for a Lens Overlay session.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayClusterInfo {
    /// ID for subsequent server requests.
    #[prost(string, tag = "1")]
    pub server_session_id: ::prost::alloc::string::String,
    /// ID for subsequent search requests.
    #[prost(string, tag = "2")]
    pub search_session_id: ::prost::alloc::string::String,
    /// Info used for routing subsequent requests.
    #[prost(message, optional, tag = "6")]
    pub routing_info: ::core::option::Option<LensOverlayRoutingInfo>,
}
/// Information about a polygon.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Polygon {
    #[prost(message, repeated, tag = "1")]
    pub vertex: ::prost::alloc::vec::Vec<polygon::Vertex>,
    #[prost(enumeration = "polygon::VertexOrdering", tag = "2")]
    pub vertex_ordering: i32,
    /// Specifies the coordinate type of vertices.
    #[prost(enumeration = "CoordinateType", tag = "3")]
    pub coordinate_type: i32,
}
/// Nested message and enum types in `Polygon`.
pub mod polygon {
    /// Represents a single vertex in the polygon.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Vertex {
        #[prost(float, tag = "1")]
        pub x: f32,
        #[prost(float, tag = "2")]
        pub y: f32,
    }
    /// Specifies the vertex ordering.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VertexOrdering {
        Unspecified = 0,
        Clockwise = 1,
        CounterClockwise = 2,
    }
    impl VertexOrdering {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VERTEX_ORDERING_UNSPECIFIED",
                Self::Clockwise => "CLOCKWISE",
                Self::CounterClockwise => "COUNTER_CLOCKWISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERTEX_ORDERING_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOCKWISE" => Some(Self::Clockwise),
                "COUNTER_CLOCKWISE" => Some(Self::CounterClockwise),
                _ => None,
            }
        }
    }
}
/// Specifies the coordinate system used for geometry protos.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoordinateType {
    /// Unspecified default value, per proto best practice.
    Unspecified = 0,
    /// Normalized coordinates.
    Normalized = 1,
    /// Image pixel coordinates.
    Image = 2,
}
impl CoordinateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COORDINATE_TYPE_UNSPECIFIED",
            Self::Normalized => "NORMALIZED",
            Self::Image => "IMAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COORDINATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NORMALIZED" => Some(Self::Normalized),
            "IMAGE" => Some(Self::Image),
            _ => None,
        }
    }
}
/// Information about a center bounding box rotated around its center.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CenterRotatedBox {
    #[prost(float, tag = "1")]
    pub center_x: f32,
    #[prost(float, tag = "2")]
    pub center_y: f32,
    #[prost(float, tag = "3")]
    pub width: f32,
    #[prost(float, tag = "4")]
    pub height: f32,
    /// Clockwise rotation around the center in radians. The rotation angle is
    /// computed before normalizing the coordinates.
    #[prost(float, tag = "5")]
    pub rotation_z: f32,
    /// Specifies the coordinate type of center and size.
    /// @note default is COORDINATE_TYPE_UNSPECIFIED, please initialize this value
    /// to NORMALIZED or IMAGE for Lens detection API usage.
    #[prost(enumeration = "CoordinateType", tag = "6")]
    pub coordinate_type: i32,
}
/// Geometric shape(s) used for tracking and detection.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Geometry {
    /// Specifies the bounding box for this geometry.
    #[prost(message, optional, tag = "1")]
    pub bounding_box: ::core::option::Option<CenterRotatedBox>,
    /// Specifies the segmentation polygon. The vertices of the outer-boundaries
    /// are in clockwise, and the ones of inner-boundaries are in counter-clockwise
    /// ordering.
    #[prost(message, repeated, tag = "5")]
    pub segmentation_polygon: ::prost::alloc::vec::Vec<Polygon>,
}
/// A cropped and potentially re-scaled image region, rectangular subregion of a
/// canonical image.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ZoomedCrop {
    /// The cropped region of the parent image in parent coordinates.
    #[prost(message, optional, tag = "1")]
    pub crop: ::core::option::Option<CenterRotatedBox>,
    /// Width of the parent image.
    #[prost(int32, tag = "2")]
    pub parent_width: i32,
    /// Height of the parent image.
    #[prost(int32, tag = "3")]
    pub parent_height: i32,
    /// The ratio of the pixel dimensions of the child image to the pixel
    /// dimensions of the 'crop' in parent coordinates.
    #[prost(float, tag = "4")]
    pub zoom: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Text {
    /// Optional. Information describing the text.
    #[prost(message, optional, tag = "1")]
    pub text_layout: ::core::option::Option<TextLayout>,
    /// Optional. Dominant content language of the text. Language
    /// code is CLDR/BCP-47.
    #[prost(string, tag = "2")]
    pub content_language: ::prost::alloc::string::String,
}
/// Nested text structure.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextLayout {
    /// Optional. List of paragraphs in natural reading order.
    #[prost(message, repeated, tag = "1")]
    pub paragraphs: ::prost::alloc::vec::Vec<text_layout::Paragraph>,
}
/// Nested message and enum types in `TextLayout`.
pub mod text_layout {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Word {
        /// Required. Unique id within TextLayout.
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::TextEntityIdentifier>,
        /// Optional. The text in a plain text.
        #[prost(string, tag = "2")]
        pub plain_text: ::prost::alloc::string::String,
        /// Optional. The text separator that should be appended after this word when
        /// it is concatenated with the subsequent word in the same or next
        /// line/paragraph into a single-line string. This is specified as optional
        /// because there is a distinction between the absence of a separator and
        /// the empty string as a separator.
        #[prost(string, optional, tag = "3")]
        pub text_separator: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. The geometry of the word.
        #[prost(message, optional, tag = "4")]
        pub geometry: ::core::option::Option<super::Geometry>,
        /// Optional. The type of this word.
        #[prost(enumeration = "word::Type", tag = "5")]
        pub r#type: i32,
        /// Optional. Metadata for formulas. This is populated for entities of
        /// `type=FORMULA`.
        #[prost(message, optional, tag = "6")]
        pub formula_metadata: ::core::option::Option<word::FormulaMetadata>,
    }
    /// Nested message and enum types in `Word`.
    pub mod word {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FormulaMetadata {
            /// Optional. LaTeX representation of a formula. Can be the same as
            /// `plain_text`. Example: "\frac{2}{x}=y". The plain text
            /// representation of this is available in Word.plain_text.
            #[prost(string, tag = "1")]
            pub latex: ::prost::alloc::string::String,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Printed text.
            Text = 0,
            /// Formula type, including mathematical or chemical formulas.
            Formula = 1,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Text => "TEXT",
                    Self::Formula => "FORMULA",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TEXT" => Some(Self::Text),
                    "FORMULA" => Some(Self::Formula),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Line {
        /// Optional. List of words in natural reading order.
        #[prost(message, repeated, tag = "1")]
        pub words: ::prost::alloc::vec::Vec<Word>,
        /// Optional. The geometry of the line.
        #[prost(message, optional, tag = "2")]
        pub geometry: ::core::option::Option<super::Geometry>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Paragraph {
        /// Required. Unique id within TextLayout.
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::TextEntityIdentifier>,
        /// Optional. List of lines in natural reading order (see also
        /// `writing_direction`).
        #[prost(message, repeated, tag = "2")]
        pub lines: ::prost::alloc::vec::Vec<Line>,
        /// Optional. Geometry of the paragraph.
        #[prost(message, optional, tag = "3")]
        pub geometry: ::core::option::Option<super::Geometry>,
        /// Optional. The text writing direction (aka reading order).
        #[prost(enumeration = "super::WritingDirection", tag = "4")]
        pub writing_direction: i32,
        /// Optional. BCP-47 language code of the dominant language in this
        /// paragraph.
        #[prost(string, tag = "5")]
        pub content_language: ::prost::alloc::string::String,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TextEntityIdentifier {
    /// Required. Unique entity id used to reference (and match) text entities and
    /// ranges.
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// The text reading order.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WritingDirection {
    DefaultWritingDirectionLeftToRight = 0,
    RightToLeft = 1,
    TopToBottom = 2,
}
impl WritingDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultWritingDirectionLeftToRight => {
                "DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT"
            }
            Self::RightToLeft => "WRITING_DIRECTION_RIGHT_TO_LEFT",
            Self::TopToBottom => "WRITING_DIRECTION_TOP_TO_BOTTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT" => {
                Some(Self::DefaultWritingDirectionLeftToRight)
            }
            "WRITING_DIRECTION_RIGHT_TO_LEFT" => Some(Self::RightToLeft),
            "WRITING_DIRECTION_TOP_TO_BOTTOM" => Some(Self::TopToBottom),
            _ => None,
        }
    }
}
/// The text alignment.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Alignment {
    DefaultLeftAligned = 0,
    RightAligned = 1,
    CenterAligned = 2,
}
impl Alignment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultLeftAligned => "DEFAULT_LEFT_ALIGNED",
            Self::RightAligned => "RIGHT_ALIGNED",
            Self::CenterAligned => "CENTER_ALIGNED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT_LEFT_ALIGNED" => Some(Self::DefaultLeftAligned),
            "RIGHT_ALIGNED" => Some(Self::RightAligned),
            "CENTER_ALIGNED" => Some(Self::CenterAligned),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeepGleamData {
    #[prost(string, repeated, tag = "11")]
    pub visual_object_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "deep_gleam_data::RenderingOneof", tags = "10")]
    pub rendering_oneof: ::core::option::Option<deep_gleam_data::RenderingOneof>,
}
/// Nested message and enum types in `DeepGleamData`.
pub mod deep_gleam_data {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RenderingOneof {
        #[prost(message, tag = "10")]
        Translation(super::TranslationData),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslationData {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<translation_data::Status>,
    #[prost(string, tag = "2")]
    pub target_language: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_language: ::prost::alloc::string::String,
    /// The translated text.
    #[prost(string, tag = "4")]
    pub translation: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub line: ::prost::alloc::vec::Vec<translation_data::Line>,
    /// The original writing direction of the source text.
    #[prost(enumeration = "WritingDirection", tag = "7")]
    pub writing_direction: i32,
    #[prost(enumeration = "Alignment", tag = "8")]
    pub alignment: i32,
    /// Whether the text is justified.
    #[prost(bool, tag = "9")]
    pub justified: bool,
}
/// Nested message and enum types in `TranslationData`.
pub mod translation_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Status {
        #[prost(enumeration = "status::Code", tag = "1")]
        pub code: i32,
    }
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Code {
            Unknown = 0,
            Success = 1,
            ServerError = 2,
            UnsupportedLanguagePair = 3,
            SameLanguage = 4,
            UnknownSourceLanguage = 5,
            InvalidRequest = 6,
            DeadlineExceeded = 7,
            EmptyTranslation = 8,
            NoOpTranslation = 9,
        }
        impl Code {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Success => "SUCCESS",
                    Self::ServerError => "SERVER_ERROR",
                    Self::UnsupportedLanguagePair => "UNSUPPORTED_LANGUAGE_PAIR",
                    Self::SameLanguage => "SAME_LANGUAGE",
                    Self::UnknownSourceLanguage => "UNKNOWN_SOURCE_LANGUAGE",
                    Self::InvalidRequest => "INVALID_REQUEST",
                    Self::DeadlineExceeded => "DEADLINE_EXCEEDED",
                    Self::EmptyTranslation => "EMPTY_TRANSLATION",
                    Self::NoOpTranslation => "NO_OP_TRANSLATION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "SUCCESS" => Some(Self::Success),
                    "SERVER_ERROR" => Some(Self::ServerError),
                    "UNSUPPORTED_LANGUAGE_PAIR" => Some(Self::UnsupportedLanguagePair),
                    "SAME_LANGUAGE" => Some(Self::SameLanguage),
                    "UNKNOWN_SOURCE_LANGUAGE" => Some(Self::UnknownSourceLanguage),
                    "INVALID_REQUEST" => Some(Self::InvalidRequest),
                    "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                    "EMPTY_TRANSLATION" => Some(Self::EmptyTranslation),
                    "NO_OP_TRANSLATION" => Some(Self::NoOpTranslation),
                    _ => None,
                }
            }
        }
    }
    /// Style as the aggregation of the styles of the words in the original text.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TextStyle {
        /// The foreground color of text in aRGB format.
        #[prost(uint32, tag = "1")]
        pub text_color: u32,
        /// The background color of text in aRGB format.
        #[prost(uint32, tag = "2")]
        pub background_primary_color: u32,
    }
    /// Properties of the image used to inpaint the source text.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BackgroundImageData {
        /// Image bytes to inpaint the source text. Contains image bytes in the
        /// format specified in file_format.
        #[prost(bytes = "vec", tag = "1")]
        pub background_image: ::prost::alloc::vec::Vec<u8>,
        /// Width of background_image in pixels.
        #[prost(int32, tag = "2")]
        pub image_width: i32,
        /// Height of background_image in pixels.
        #[prost(int32, tag = "3")]
        pub image_height: i32,
        /// Vertical padding to apply to the text box before drawing the background
        /// image. Expressed as a fraction of the text box height, i.e. 1.0 means
        /// that the height should be doubled. Half of the padding should be added on
        /// the top and half on the bottom.
        #[prost(float, tag = "4")]
        pub vertical_padding: f32,
        /// Horizontal padding to apply to the text box before drawing the background
        /// image. Expressed as a fraction of the text box height. Half of the
        /// padding should be added on the left and half on the right.
        #[prost(float, tag = "5")]
        pub horizontal_padding: f32,
        #[prost(enumeration = "background_image_data::FileFormat", tag = "6")]
        pub file_format: i32,
        /// Text mask for the generated background image.
        #[prost(bytes = "vec", tag = "7")]
        pub text_mask: ::prost::alloc::vec::Vec<u8>,
    }
    /// Nested message and enum types in `BackgroundImageData`.
    pub mod background_image_data {
        /// File format of the bytes in background_image.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FileFormat {
            Unknown = 0,
            RawBytesRgba = 1,
            PngRgba = 2,
            WebpRgba = 3,
            JpegRgbPngMask = 4,
        }
        impl FileFormat {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::RawBytesRgba => "RAW_BYTES_RGBA",
                    Self::PngRgba => "PNG_RGBA",
                    Self::WebpRgba => "WEBP_RGBA",
                    Self::JpegRgbPngMask => "JPEG_RGB_PNG_MASK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "RAW_BYTES_RGBA" => Some(Self::RawBytesRgba),
                    "PNG_RGBA" => Some(Self::PngRgba),
                    "WEBP_RGBA" => Some(Self::WebpRgba),
                    "JPEG_RGB_PNG_MASK" => Some(Self::JpegRgbPngMask),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Line {
        /// A substring from the translation from start to end (exclusive),
        /// that needs to be distributed on this line, measured in Unicode
        /// characters. If not set, the Line doesn't have any translation.
        #[prost(int32, tag = "1")]
        pub start: i32,
        #[prost(int32, tag = "2")]
        pub end: i32,
        #[prost(message, optional, tag = "3")]
        pub style: ::core::option::Option<TextStyle>,
        #[prost(message, repeated, tag = "5")]
        pub word: ::prost::alloc::vec::Vec<line::Word>,
        /// Background image data is set only when inpainting is computed.
        #[prost(message, optional, tag = "9")]
        pub background_image_data: ::core::option::Option<BackgroundImageData>,
    }
    /// Nested message and enum types in `Line`.
    pub mod line {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Word {
            /// A substring from the translation from start to end (exclusive),
            /// representing a word (without separator), measured in Unicode
            /// characters.
            #[prost(int32, tag = "1")]
            pub start: i32,
            #[prost(int32, tag = "2")]
            pub end: i32,
        }
    }
}
/// Top-level PDF representation extracted using Pdfium.
/// Next ID: 6
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayDocument {
    /// Ordered pdf pages.
    #[prost(message, repeated, tag = "1")]
    pub pages: ::prost::alloc::vec::Vec<Page>,
}
/// Represents a single page of the PDF.
/// Next ID: 10
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Page {
    /// Page number in the pdf (indexed starting at 1).
    #[prost(int32, tag = "1")]
    pub page_number: i32,
    /// List of text segments of the page.
    #[prost(string, repeated, tag = "4")]
    pub text_segments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Image data from the client.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientImage {
    /// Required. A byte array encoding an image.
    #[prost(bytes = "vec", tag = "1")]
    pub image_content: ::prost::alloc::vec::Vec<u8>,
}
/// User-selected / auto-detected cropped image region.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageCrop {
    /// The ID of the cropped image region.
    #[prost(string, tag = "1")]
    pub crop_id: ::prost::alloc::string::String,
    /// The image content of the cropped image region.
    #[prost(message, optional, tag = "2")]
    pub image: ::core::option::Option<ClientImage>,
    /// The zoomed crop properties of the cropped image region.
    #[prost(message, optional, tag = "3")]
    pub zoomed_crop: ::core::option::Option<ZoomedCrop>,
}
/// Data representing image. Contains image bytes or image retrieval identifier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageData {
    /// Image payload to process. This contains image bytes.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<ImagePayload>,
    /// Required. Context of the given image.
    #[prost(message, optional, tag = "3")]
    pub image_metadata: ::core::option::Option<ImageMetadata>,
    /// The bounds of significant regions in the image.
    #[prost(message, repeated, tag = "4")]
    pub significant_regions: ::prost::alloc::vec::Vec<Geometry>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePayload {
    /// Required. Image byte array.
    #[prost(bytes = "vec", tag = "1")]
    pub image_bytes: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImageMetadata {
    /// Required. Image width in pixels. Should reflect the actual size of
    /// image_bytes.
    #[prost(int32, tag = "1")]
    pub width: i32,
    /// Required. Image height in pixels. Should reflect the actual size of
    /// image_bytes.
    #[prost(int32, tag = "2")]
    pub height: i32,
}
/// Contains an unstructured text query to add to an image query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextQuery {
    /// The unstructured text query, such as "blue" or "blouse".
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_primary: bool,
}
/// Metadata associated with an interaction request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayInteractionRequestMetadata {
    #[prost(enumeration = "lens_overlay_interaction_request_metadata::Type", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub selection_metadata: ::core::option::Option<
        lens_overlay_interaction_request_metadata::SelectionMetadata,
    >,
    #[prost(message, optional, tag = "4")]
    pub query_metadata: ::core::option::Option<
        lens_overlay_interaction_request_metadata::QueryMetadata,
    >,
}
/// Nested message and enum types in `LensOverlayInteractionRequestMetadata`.
pub mod lens_overlay_interaction_request_metadata {
    /// Metadata related to the selection associated with this interaction request.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SelectionMetadata {
        #[prost(oneof = "selection_metadata::Selection", tags = "1, 2, 3")]
        pub selection: ::core::option::Option<selection_metadata::Selection>,
    }
    /// Nested message and enum types in `SelectionMetadata`.
    pub mod selection_metadata {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Point {
            #[prost(float, tag = "1")]
            pub x: f32,
            #[prost(float, tag = "2")]
            pub y: f32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Region {
            #[prost(message, optional, tag = "1")]
            pub region: ::core::option::Option<super::super::CenterRotatedBox>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Object {
            #[prost(string, tag = "1")]
            pub object_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub geometry: ::core::option::Option<super::super::Geometry>,
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Selection {
            #[prost(message, tag = "1")]
            Point(Point),
            #[prost(message, tag = "2")]
            Region(Region),
            #[prost(message, tag = "3")]
            Object(Object),
        }
    }
    /// Metadata related to query.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryMetadata {
        /// The text query information.
        #[prost(message, optional, tag = "2")]
        pub text_query: ::core::option::Option<super::TextQuery>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        /// User's tap on the screen.
        Tap = 1,
        /// User's region selection on the screenshot.
        Region = 2,
        /// User's text selection on the screenshot.
        TextSelection = 3,
        /// User selected a bounding box to region search.
        RegionSearch = 4,
        /// Requests selection and fulfillment of a specific object.
        ObjectFulfillment = 5,
        /// User sent a query in the contextual search box.
        ContextualSearchQuery = 9,
        /// User sent a query about a pdf.
        PdfQuery = 10,
        /// User sent a query about a website.
        WebpageQuery = 11,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Tap => "TAP",
                Self::Region => "REGION",
                Self::TextSelection => "TEXT_SELECTION",
                Self::RegionSearch => "REGION_SEARCH",
                Self::ObjectFulfillment => "OBJECT_FULFILLMENT",
                Self::ContextualSearchQuery => "CONTEXTUAL_SEARCH_QUERY",
                Self::PdfQuery => "PDF_QUERY",
                Self::WebpageQuery => "WEBPAGE_QUERY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "TAP" => Some(Self::Tap),
                "REGION" => Some(Self::Region),
                "TEXT_SELECTION" => Some(Self::TextSelection),
                "REGION_SEARCH" => Some(Self::RegionSearch),
                "OBJECT_FULFILLMENT" => Some(Self::ObjectFulfillment),
                "CONTEXTUAL_SEARCH_QUERY" => Some(Self::ContextualSearchQuery),
                "PDF_QUERY" => Some(Self::PdfQuery),
                "WEBPAGE_QUERY" => Some(Self::WebpageQuery),
                _ => None,
            }
        }
    }
}
/// Signals specific to queries coming from translate stickiness extension.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TranslateStickinessSignals {
    #[prost(bool, tag = "1")]
    pub translate_suppress_echo_for_sticky: bool,
}
/// A message representing the function call of an answers intent query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCall {
    /// Name of this function call.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A list of arguments of this function call.
    #[prost(message, repeated, tag = "2")]
    pub argument: ::prost::alloc::vec::Vec<Argument>,
    /// Signals at the function call level
    #[prost(message, optional, tag = "4")]
    pub signals: ::core::option::Option<FunctionCallSignals>,
}
/// Signals at the function call level
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FunctionCallSignals {
    #[prost(message, optional, tag = "311378150")]
    pub translate_stickiness_signals: ::core::option::Option<TranslateStickinessSignals>,
}
/// A message representing the function argument.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Argument {
    /// Name of this argument.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The value of this argument.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<ArgumentValue>,
}
/// A message representing the value of an argument.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArgumentValue {
    #[prost(oneof = "argument_value::Value", tags = "3")]
    pub value: ::core::option::Option<argument_value::Value>,
}
/// Nested message and enum types in `ArgumentValue`.
pub mod argument_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "3")]
        SimpleValue(super::SimpleValue),
    }
}
/// A message representing a simple literal value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleValue {
    #[prost(oneof = "simple_value::Value", tags = "1")]
    pub value: ::core::option::Option<simple_value::Value>,
}
/// Nested message and enum types in `SimpleValue`.
pub mod simple_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
    }
}
/// A Query is a representation of the meaning of the user query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
    #[prost(message, optional, tag = "56249026")]
    pub intent_query: ::core::option::Option<FunctionCall>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MathSolverQuery {
    #[prost(string, tag = "3")]
    pub math_input_equation: ::prost::alloc::string::String,
}
/// This is proto2's version of MessageSet.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageSet {
    #[prost(message, optional, tag = "41401449")]
    pub message_set_extension: ::core::option::Option<Query>,
}
/// Overlay Object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OverlayObject {
    /// The id.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The object geometry.
    #[prost(message, optional, tag = "2")]
    pub geometry: ::core::option::Option<Geometry>,
    /// The rendering metadata for the object.
    #[prost(message, optional, tag = "8")]
    pub rendering_metadata: ::core::option::Option<overlay_object::RenderingMetadata>,
    #[prost(message, optional, tag = "4")]
    pub interaction_properties: ::core::option::Option<
        overlay_object::InteractionProperties,
    >,
    /// Indicates to the client that this object is eligible to be an object
    /// fulfillment request.
    #[prost(bool, tag = "9")]
    pub is_fulfilled: bool,
}
/// Nested message and enum types in `OverlayObject`.
pub mod overlay_object {
    /// Rendering metadata for the object.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RenderingMetadata {
        #[prost(enumeration = "rendering_metadata::RenderType", tag = "1")]
        pub render_type: i32,
    }
    /// Nested message and enum types in `RenderingMetadata`.
    pub mod rendering_metadata {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum RenderType {
            Default = 0,
            Gleam = 1,
        }
        impl RenderType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Default => "DEFAULT",
                    Self::Gleam => "GLEAM",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DEFAULT" => Some(Self::Default),
                    "GLEAM" => Some(Self::Gleam),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InteractionProperties {
        /// Whether an object can be tapped
        #[prost(bool, tag = "1")]
        pub select_on_tap: bool,
    }
}
/// Request Id definition to support request sequencing and state lookup.
/// Next Id: 10
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayRequestId {
    /// A unique identifier for a sequence of related Lens requests.
    #[prost(uint64, tag = "1")]
    pub uuid: u64,
    /// An id to indicate the order of the current request within a sequence of
    /// requests sharing the same uuid. Starts from 1, increments by 1 if there is
    /// a new request with the same uuid.
    #[prost(int32, tag = "2")]
    pub sequence_id: i32,
    /// An id to indicate the order of image payload sent within a sequence of
    /// requests sharing the same uuid. Starts from 1, increments by 1 if there is
    /// a new request with an image payload with the same uuid.
    /// Note, region search request does not increment this id.
    #[prost(int32, tag = "3")]
    pub image_sequence_id: i32,
    /// Analytics ID for the Lens request. Will be updated on the initial request
    /// and once per interaction request.
    #[prost(bytes = "vec", tag = "4")]
    pub analytics_id: ::prost::alloc::vec::Vec<u8>,
    /// An id to indicate the order of contextual document payloads sent within a
    /// sequence of requests sharing the same uuid. Starts from 1, increments by 1
    /// if there is a new request with a contextual payload with the same uuid.
    #[prost(int32, tag = "9")]
    pub long_context_id: i32,
    /// Information about where to route the request.
    #[prost(message, optional, tag = "6")]
    pub routing_info: ::core::option::Option<LensOverlayRoutingInfo>,
}
/// The type of the request the payload is sent in.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RequestType {
    /// Unset Request type.
    Default = 0,
    /// Request is for PDF.
    Pdf = 1,
    /// Request is for partial PDF upload.
    EarlyPartialPdf = 3,
    /// Request is for webpage.
    Webpage = 2,
}
impl RequestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "REQUEST_TYPE_DEFAULT",
            Self::Pdf => "REQUEST_TYPE_PDF",
            Self::EarlyPartialPdf => "REQUEST_TYPE_EARLY_PARTIAL_PDF",
            Self::Webpage => "REQUEST_TYPE_WEBPAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REQUEST_TYPE_DEFAULT" => Some(Self::Default),
            "REQUEST_TYPE_PDF" => Some(Self::Pdf),
            "REQUEST_TYPE_EARLY_PARTIAL_PDF" => Some(Self::EarlyPartialPdf),
            "REQUEST_TYPE_WEBPAGE" => Some(Self::Webpage),
            _ => None,
        }
    }
}
/// Possible selection types for Lens overlay.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LensOverlaySelectionType {
    UnknownSelectionType = 0,
    TapOnEmpty = 1,
    SelectTextHighlight = 3,
    RegionSearch = 7,
    InjectedImage = 10,
    TapOnRegionGleam = 15,
    MultimodalSearch = 18,
    SelectTranslatedText = 21,
    TapOnObject = 22,
    MultimodalSuggestTypeahead = 25,
    MultimodalSuggestZeroPrefix = 26,
    TranslateChip = 52,
    SymbolicMathObject = 53,
}
impl LensOverlaySelectionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownSelectionType => "UNKNOWN_SELECTION_TYPE",
            Self::TapOnEmpty => "TAP_ON_EMPTY",
            Self::SelectTextHighlight => "SELECT_TEXT_HIGHLIGHT",
            Self::RegionSearch => "REGION_SEARCH",
            Self::InjectedImage => "INJECTED_IMAGE",
            Self::TapOnRegionGleam => "TAP_ON_REGION_GLEAM",
            Self::MultimodalSearch => "MULTIMODAL_SEARCH",
            Self::SelectTranslatedText => "SELECT_TRANSLATED_TEXT",
            Self::TapOnObject => "TAP_ON_OBJECT",
            Self::MultimodalSuggestTypeahead => "MULTIMODAL_SUGGEST_TYPEAHEAD",
            Self::MultimodalSuggestZeroPrefix => "MULTIMODAL_SUGGEST_ZERO_PREFIX",
            Self::TranslateChip => "TRANSLATE_CHIP",
            Self::SymbolicMathObject => "SYMBOLIC_MATH_OBJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_SELECTION_TYPE" => Some(Self::UnknownSelectionType),
            "TAP_ON_EMPTY" => Some(Self::TapOnEmpty),
            "SELECT_TEXT_HIGHLIGHT" => Some(Self::SelectTextHighlight),
            "REGION_SEARCH" => Some(Self::RegionSearch),
            "INJECTED_IMAGE" => Some(Self::InjectedImage),
            "TAP_ON_REGION_GLEAM" => Some(Self::TapOnRegionGleam),
            "MULTIMODAL_SEARCH" => Some(Self::MultimodalSearch),
            "SELECT_TRANSLATED_TEXT" => Some(Self::SelectTranslatedText),
            "TAP_ON_OBJECT" => Some(Self::TapOnObject),
            "MULTIMODAL_SUGGEST_TYPEAHEAD" => Some(Self::MultimodalSuggestTypeahead),
            "MULTIMODAL_SUGGEST_ZERO_PREFIX" => Some(Self::MultimodalSuggestZeroPrefix),
            "TRANSLATE_CHIP" => Some(Self::TranslateChip),
            "SYMBOLIC_MATH_OBJECT" => Some(Self::SymbolicMathObject),
            _ => None,
        }
    }
}
/// Request context for a Lens Overlay request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayRequestContext {
    /// Required. Identifiers for this request.
    #[prost(message, optional, tag = "3")]
    pub request_id: ::core::option::Option<LensOverlayRequestId>,
    /// The client context for the request.
    #[prost(message, optional, tag = "4")]
    pub client_context: ::core::option::Option<LensOverlayClientContext>,
}
/// Context information about the viewport for the request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ViewportRequestContext {
    /// Optional. Pdf page number the user is viewing for contextual search
    /// requests. Only sent with viewport requests on pdf documents.
    #[prost(int32, tag = "1")]
    pub pdf_page_number: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayObjectsRequest {
    /// Required. Basic information and context for the request.
    #[prost(message, optional, tag = "1")]
    pub request_context: ::core::option::Option<LensOverlayRequestContext>,
    /// Required. Image Data to process.
    #[prost(message, optional, tag = "3")]
    pub image_data: ::core::option::Option<ImageData>,
    /// Optional. Data payload of the request.
    /// TODO(b/359638436): Mark required when clients have migrated to use Payload
    /// field.
    #[prost(message, optional, tag = "4")]
    pub payload: ::core::option::Option<Payload>,
    /// Optional. Viewport context for contextual search viewport requests.
    #[prost(message, optional, tag = "5")]
    pub viewport_request_context: ::core::option::Option<ViewportRequestContext>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayUploadChunkRequest {
    /// Required. Chunks of the same payload should have the same request
    /// context.
    #[prost(message, optional, tag = "1")]
    pub request_context: ::core::option::Option<LensOverlayRequestContext>,
    /// Optional. Debug options for the request.
    #[prost(message, optional, tag = "6")]
    pub debug_options: ::core::option::Option<ChunkDebugOptions>,
    /// Required. The id of the chunk. This should start from 0 for the first
    /// chunk and go up to (total_chunks - 1) in sequential chunk order.
    #[prost(int64, tag = "3")]
    pub chunk_id: i64,
    /// Required. The bytes of the payload chunk to upload.
    #[prost(bytes = "vec", tag = "4")]
    pub chunk_bytes: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayUploadChunkResponse {
    /// Debug metadata from the upload chunk response.
    #[prost(message, optional, tag = "2")]
    pub debug_metadata: ::core::option::Option<ChunkDebugMetadata>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChunkDebugOptions {
    /// Required in first chunk request of the payload. Optional afterwards.
    /// Total number of chunks that will be uploaded to Lens server for the given
    /// payload.
    #[prost(int64, tag = "1")]
    pub total_chunks: i64,
    /// Optional. When true, Lens server will return a repeated list of remaining
    /// chunk ids that it expects to receive to complete the payload. Should only
    /// be used for debugging purposes.
    #[prost(bool, tag = "2")]
    pub query_chunks: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkDebugMetadata {
    /// Only populated if ChunkDebugOptions.query_chunks is true in the
    /// UploadChunk request. List of chunk ids that Lens server is expecting to
    /// complete the payload. Should only be used for debugging purposes.
    #[prost(int64, repeated, tag = "1")]
    pub remaining_chunks: ::prost::alloc::vec::Vec<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayObjectsResponse {
    /// Overlay objects.
    #[prost(message, repeated, tag = "2")]
    pub overlay_objects: ::prost::alloc::vec::Vec<OverlayObject>,
    /// Text.
    #[prost(message, optional, tag = "3")]
    pub text: ::core::option::Option<Text>,
    /// Gleams.
    #[prost(message, repeated, tag = "4")]
    pub deep_gleams: ::prost::alloc::vec::Vec<DeepGleamData>,
    /// The cluster info.
    #[prost(message, optional, tag = "7")]
    pub cluster_info: ::core::option::Option<LensOverlayClusterInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayInteractionRequest {
    /// Basic information and context for the request.
    #[prost(message, optional, tag = "1")]
    pub request_context: ::core::option::Option<LensOverlayRequestContext>,
    /// Metadata associated with an interaction request.
    #[prost(message, optional, tag = "2")]
    pub interaction_request_metadata: ::core::option::Option<
        LensOverlayInteractionRequestMetadata,
    >,
    /// The image crop data.
    #[prost(message, optional, tag = "3")]
    pub image_crop: ::core::option::Option<ImageCrop>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayInteractionResponse {
    #[prost(string, tag = "3")]
    pub encoded_response: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub text: ::core::option::Option<Text>,
}
/// Next ID: 11
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    /// Optional. The type of the request.
    #[prost(enumeration = "RequestType", tag = "6")]
    pub request_type: i32,
    /// Currently unset, use image_data in ObjectsRequest.
    /// TODO(b/359638436): Move ObjectsRequest clients onto Payload.ImageData.
    #[prost(message, optional, tag = "2")]
    pub image_data: ::core::option::Option<ImageData>,
    /// Data for non-image payloads. May be sent with or without an image in the
    /// image_data field. If content_data is set, content_type must also be set.
    /// TODO(crbug.com/399173540): Deprecate this field in favor of content.
    #[prost(bytes = "vec", tag = "3")]
    pub content_data: ::prost::alloc::vec::Vec<u8>,
    /// The media type/MIME type of the data represented i content_data, e.g.
    /// "application/pdf". If content_type is set, content_data should also be set.
    /// TODO(crbug.com/399173540): Deprecate this field in favor of content.
    #[prost(string, tag = "4")]
    pub content_type: ::prost::alloc::string::String,
    /// The page url this request was made on.
    /// TODO(crbug.com/399173540): Deprecate this field in favor of content.
    #[prost(string, tag = "5")]
    pub page_url: ::prost::alloc::string::String,
    /// The partially parsed PDF document. Used to get early suggest signals. This
    /// is only set for REQUEST_TYPE_EARLY_PARTIAL_PDF.
    /// TODO(crbug.com/399173540): Deprecate this field in favor of content.
    #[prost(message, optional, tag = "7")]
    pub partial_pdf_document: ::core::option::Option<LensOverlayDocument>,
    /// Compression format of content_data. Currently only used for PDF data.
    /// TODO(crbug.com/399173540): Deprecate this field in favor of content.
    #[prost(enumeration = "CompressionType", tag = "8")]
    pub compression_type: i32,
    /// Optional. Options for reading stored chunks from state layer.
    /// TODO(crbug.com/399173540): Deprecate this field in favor of content.
    #[prost(message, optional, tag = "9")]
    pub stored_chunk_options: ::core::option::Option<StoredChunkOptions>,
    /// Non-image content to be sent to the Lens server.
    #[prost(message, optional, tag = "10")]
    pub content: ::core::option::Option<Content>,
}
/// Specifies the options for the server to use when reading stored chunks from
/// state layer during a streamed request.
/// Next ID: 3
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StoredChunkOptions {
    /// When set to true, Lens will retrieve payload chunks uploaded to state
    /// layer via the UploadChunk API and use those to construct
    /// content_data. If this is set, then content_type and total_stored_chunks
    /// must also be set.
    #[prost(bool, tag = "1")]
    pub read_stored_chunks: bool,
    /// The total number of chunks the payload was split into. This is used to
    /// facilitate the reconstruction of content_data.
    #[prost(int64, tag = "2")]
    pub total_stored_chunks: i64,
}
/// Generic content message for all types of content that can be sent to Lens.
/// Next ID: 5
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    /// Optional. Page url for the webpage.
    #[prost(string, tag = "1")]
    pub webpage_url: ::prost::alloc::string::String,
    /// Optional. Page title of the webpage.
    #[prost(string, tag = "4")]
    pub webpage_title: ::prost::alloc::string::String,
    /// Optional. Content items for the request.
    #[prost(message, repeated, tag = "2")]
    pub content_data: ::prost::alloc::vec::Vec<ContentData>,
    /// The type of the request.
    #[prost(enumeration = "RequestType", tag = "3")]
    pub request_type: i32,
}
/// Generic content data message for all types of content that can be sent to
/// Lens.
/// Next ID: 5
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentData {
    /// The type of the content.
    #[prost(enumeration = "content_data::ContentType", tag = "1")]
    pub content_type: i32,
    /// The content data.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Compression format of content_data.
    #[prost(enumeration = "CompressionType", tag = "3")]
    pub compression_type: i32,
    /// Optional. Options for reading stored chunks from state layer.
    #[prost(message, optional, tag = "4")]
    pub stored_chunk_options: ::core::option::Option<StoredChunkOptions>,
}
/// Nested message and enum types in `ContentData`.
pub mod content_data {
    /// Possible types of the content.
    /// Next ID: 6
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentType {
        /// Default value.
        Unspecified = 0,
        /// PDF content.
        Pdf = 1,
        /// Inner text content.
        InnerText = 2,
        /// Inner HTML content.
        InnerHtml = 3,
        /// Annotated page content.
        AnnotatedPageContent = 4,
        /// Early partial PDF content.
        EarlyPartialPdf = 5,
    }
    impl ContentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONTENT_TYPE_UNSPECIFIED",
                Self::Pdf => "CONTENT_TYPE_PDF",
                Self::InnerText => "CONTENT_TYPE_INNER_TEXT",
                Self::InnerHtml => "CONTENT_TYPE_INNER_HTML",
                Self::AnnotatedPageContent => "CONTENT_TYPE_ANNOTATED_PAGE_CONTENT",
                Self::EarlyPartialPdf => "CONTENT_TYPE_EARLY_PARTIAL_PDF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONTENT_TYPE_PDF" => Some(Self::Pdf),
                "CONTENT_TYPE_INNER_TEXT" => Some(Self::InnerText),
                "CONTENT_TYPE_INNER_HTML" => Some(Self::InnerHtml),
                "CONTENT_TYPE_ANNOTATED_PAGE_CONTENT" => Some(Self::AnnotatedPageContent),
                "CONTENT_TYPE_EARLY_PARTIAL_PDF" => Some(Self::EarlyPartialPdf),
                _ => None,
            }
        }
    }
}
/// Possible compression types for content_data.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionType {
    /// Default value. File is not compressed.
    Uncompressed = 0,
    /// ZSTD compression.
    Zstd = 1,
}
impl CompressionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Uncompressed => "UNCOMPRESSED",
            Self::Zstd => "ZSTD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNCOMPRESSED" => Some(Self::Uncompressed),
            "ZSTD" => Some(Self::Zstd),
            _ => None,
        }
    }
}
/// The cluster info request for a Lens Overlay session.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LensOverlayServerClusterInfoRequest {
    /// Whether to return a search session id alongside the server session id.
    #[prost(bool, tag = "1")]
    pub enable_search_session_id: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayServerClusterInfoResponse {
    /// ID for subsequent server requests.
    #[prost(string, tag = "1")]
    pub server_session_id: ::prost::alloc::string::String,
    /// ID for subsequent search requests.
    #[prost(string, tag = "2")]
    pub search_session_id: ::prost::alloc::string::String,
    /// The routing info for the server session.
    #[prost(message, optional, tag = "3")]
    pub routing_info: ::core::option::Option<LensOverlayRoutingInfo>,
}
/// An error encountered while handling a request.
/// Next ID: 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LensOverlayServerError {
    /// The error type.
    #[prost(enumeration = "lens_overlay_server_error::ErrorType", tag = "1")]
    pub error_type: i32,
}
/// Nested message and enum types in `LensOverlayServerError`.
pub mod lens_overlay_server_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorType {
        UnknownType = 0,
        MissingRequest = 1,
    }
    impl ErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownType => "UNKNOWN_TYPE",
                Self::MissingRequest => "MISSING_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_TYPE" => Some(Self::UnknownType),
                "MISSING_REQUEST" => Some(Self::MissingRequest),
                _ => None,
            }
        }
    }
}
/// Next ID: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayServerRequest {
    /// Options for fetching objects.
    #[prost(message, optional, tag = "1")]
    pub objects_request: ::core::option::Option<LensOverlayObjectsRequest>,
    /// Options for fetching interactions.
    #[prost(message, optional, tag = "2")]
    pub interaction_request: ::core::option::Option<LensOverlayInteractionRequest>,
    /// Client logs for the request.
    #[prost(message, optional, tag = "3")]
    pub client_logs: ::core::option::Option<LensOverlayClientLogs>,
}
/// Response details for an LensOverlay request.
/// Next ID: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayServerResponse {
    /// The encountered error.
    #[prost(message, optional, tag = "1")]
    pub error: ::core::option::Option<LensOverlayServerError>,
    /// The objects response.
    #[prost(message, optional, tag = "2")]
    pub objects_response: ::core::option::Option<LensOverlayObjectsResponse>,
    /// The interaction response.
    #[prost(message, optional, tag = "3")]
    pub interaction_response: ::core::option::Option<LensOverlayInteractionResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StickinessSignals {
    #[prost(enumeration = "stickiness_signals::Namespace", optional, tag = "1")]
    pub id_namespace: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "28")]
    pub interpretation: ::core::option::Option<MessageSet>,
    #[prost(message, optional, tag = "121")]
    pub education_input_extension: ::core::option::Option<EducationInputExtension>,
}
/// Nested message and enum types in `StickinessSignals`.
pub mod stickiness_signals {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Namespace {
        Unknown = 0,
        TranslateLite = 56,
        EducationInput = 79,
    }
    impl Namespace {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::TranslateLite => "TRANSLATE_LITE",
                Self::EducationInput => "EDUCATION_INPUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "TRANSLATE_LITE" => Some(Self::TranslateLite),
                "EDUCATION_INPUT" => Some(Self::EducationInput),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EducationInputExtension {
    #[prost(message, optional, tag = "1")]
    pub math_solver_query: ::core::option::Option<MathSolverQuery>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayVideoContextInputParams {
    /// Url of the video.
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayVideoParams {
    /// Video context params from input.
    #[prost(message, optional, tag = "1")]
    pub video_context_input_params: ::core::option::Option<
        LensOverlayVideoContextInputParams,
    >,
}
/// Log data for a Lens Overlay visual search interaction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LensOverlayVisualSearchInteractionLogData {
    /// Filter related metadata.
    #[prost(message, optional, tag = "1")]
    pub filter_data: ::core::option::Option<FilterData>,
    /// User Selection metadata.
    #[prost(message, optional, tag = "2")]
    pub user_selection_data: ::core::option::Option<UserSelectionData>,
    /// Whether the query is a parent query.
    #[prost(bool, tag = "3")]
    pub is_parent_query: bool,
    /// The client platform this query was originated from.
    #[prost(enumeration = "ClientPlatform", tag = "4")]
    pub client_platform: i32,
}
/// Filter data.
/// Next ID: 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FilterData {
    /// The filter type associated with this interaction (auto, translate, etc.).
    #[prost(enumeration = "LensOverlayFilterType", tag = "1")]
    pub filter_type: i32,
}
/// User selection data.
/// Next ID: 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserSelectionData {
    /// The selection type associated with this interaction (e.g. region search).
    #[prost(enumeration = "LensOverlaySelectionType", tag = "1")]
    pub selection_type: i32,
}
/// Metadata associated with a Lens Visual Search request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensOverlayVisualSearchInteractionData {
    /// The type of interaction.
    #[prost(enumeration = "lens_overlay_interaction_request_metadata::Type", tag = "1")]
    pub interaction_type: i32,
    /// The selected region for this interaction, instead of the object id.
    #[prost(message, optional, tag = "7")]
    pub zoomed_crop: ::core::option::Option<ZoomedCrop>,
    /// The selected object id for this interaction, instead of the zoomed crop.
    /// Currently unsupported and should not be populated.
    #[prost(string, tag = "3")]
    pub object_id: ::prost::alloc::string::String,
    /// Logging-specific data.
    #[prost(message, optional, tag = "5")]
    pub log_data: ::core::option::Option<LensOverlayVisualSearchInteractionLogData>,
}

